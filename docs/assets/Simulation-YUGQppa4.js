var Z=Object.defineProperty;var J=(n,o,e)=>o in n?Z(n,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[o]=e;var x=(n,o,e)=>(J(n,typeof o!="symbol"?o+"":o,e),e);import"./modulepreload-polyfill-9p4a8sJU.js";import{V as p,e as K,f as q,B as $,g as b,b as H,h as G,i as _,j,k as ee,l as te,m as ne,n as ie,o as re,p as ae,Q as E,W as se,S as oe,C as ce,P as de,A as he,H as le,D as ue,O as me,q as pe,R as fe,a as U,M as ge,d as ve}from"./OrbitControls-j09ctz_t.js";import{D as ye}from"./DragControls-cTQUHdrk.js";import{c as xe}from"./simplex-noise-jK7XNhv8.js";var we=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},Pe={exports:{}};(function(n,o){(function(e,i){n.exports=i()})(we,function(){return e.importState=function(t){var r=new e;return r.importState(t),r},e;function e(){return function(t){var r=0,a=0,s=0,u=1;t.length==0&&(t=[+new Date]);var f=i();r=f(" "),a=f(" "),s=f(" ");for(var h=0;h<t.length;h++)r-=f(t[h]),r<0&&(r+=1),a-=f(t[h]),a<0&&(a+=1),s-=f(t[h]),s<0&&(s+=1);f=null;var l=function(){var m=2091639*r+u*23283064365386963e-26;return r=a,a=s,s=m-(u=m|0)};return l.next=l,l.uint32=function(){return l()*4294967296},l.fract53=function(){return l()+(l()*2097152|0)*11102230246251565e-32},l.version="Alea 0.9",l.args=t,l.exportState=function(){return[r,a,s,u]},l.importState=function(m){r=+m[0]||0,a=+m[1]||0,s=+m[2]||0,u=+m[3]||0},l}(Array.prototype.slice.call(arguments))}function i(){var t=4022871197,r=function(a){a=a.toString();for(var s=0;s<a.length;s++){t+=a.charCodeAt(s);var u=.02519603282416938*t;t=u>>>0,u-=t,u*=t,t=u>>>0,u-=t,t+=u*4294967296}return(t>>>0)*23283064365386963e-26};return r.version="Mash 0.9",r}})})(Pe);class Q{constructor(o,e,i,t){this.pos=new p(o,e,i),this.vel=new p,this.acc=new p,this.mass=t}steer(o){o.sub(this.vel),this.applyForce(o)}applyForce(o){o.divideScalar(this.mass),this.acc.add(o),this.vel.add(this.acc),this.pos.add(this.vel),this.acc=new p(0,0,0)}follow(o){var e=this.pos.x/100,i=this.pos.y/100,t=this.pos.z/100,r=o(e,i,t,.5),a=o(e,i,t,1);let s=new p(Math.cos(r*Math.PI)*Math.sin(a*Math.PI),Math.sin(r*Math.PI)*Math.cos(a*Math.PI),Math.cos(r*Math.PI));s.normalize(),this.applyForce(s)}attract(o){let e=new p().subVectors(this.pos,o.pos),i=this.pos.distanceTo(o.pos);i<100&&(i=100),i>1e3&&(i=500);let r=10*(this.mass*o.mass)/(i*i);e.normalize(),e.multiplyScalar(r),o.applyForce(e)}}const c=class c extends K{constructor(e,i){super();x(this,"advance",function(){const e=new G;return function(){this.targetObject.updateMatrixWorld(),e.copy(this.targetObject.matrixWorld),this.advanceWithTransform(e),this.updateUniforms()}}());x(this,"advanceGeometry",function(){return function(i,t){const r=this.currentEnd+1>=this.length?0:this.currentEnd+1;if(t?this.updateNodePositionsFromTransformMatrix(r,t):this.updateNodePositionsFromOrientationTangent(r,i.position,i.tangent),this.currentLength>=1&&(this.connectNodes(this.currentEnd,r),this.currentLength>=this.length)){const a=this.currentEnd+1>=this.length?0:this.currentEnd+1;this.disconnectNodes(a)}this.currentLength<this.length&&this.currentLength++,this.currentEnd++,this.currentEnd>=this.length&&(this.currentEnd=0),this.currentLength>=1&&(this.currentLength<this.length?this.geometry.setDrawRange(0,(this.currentLength-1)*this.FaceIndicesPerNode):this.geometry.setDrawRange(0,this.currentLength*this.FaceIndicesPerNode)),this.updateNodeID(this.currentEnd,this.currentNodeID),this.currentNodeID++}}());x(this,"updateHead",function(){const e=new G;return function(){this.currentEnd<0||(this.targetObject.updateMatrixWorld(),e.copy(this.targetObject.matrixWorld),this.updateNodePositionsFromTransformMatrix(this.currentEnd,e))}}());x(this,"updateNodePositionsFromOrientationTangent",function(){const e=new E,i=new p,t=[];for(let r=0;r<c.MaxHeadVertices;r++){const a=new p;t.push(a)}return function(a,s,u){const f=this.geometry.getAttribute("position");this.updateNodeCenter(a,s),i.copy(s),i.sub(c.LocalHeadOrigin),e.setFromUnitVectors(c.LocalOrientationTangent,u);for(let h=0;h<this.localHeadGeometry.length;h++){const l=t[h];l.copy(this.localHeadGeometry[h]),l.applyQuaternion(e),l.add(i)}for(let h=0;h<this.localHeadGeometry.length;h++){const l=(this.VerticesPerNode*a+h)*c.PositionComponentCount,m=t[h];f.array[l]=m.x,f.array[l+1]=m.y,f.array[l+2]=m.z}f.needsUpdate=!0}}());x(this,"updateNodePositionsFromTransformMatrix",function(){const e=new _,i=new E,t=new p,r=new p,a=new p,s=new p,u=[];for(let h=0;h<c.MaxHeadVertices;h++){const l=new p;u.push(l)}function f(h,l){const m=l.elements;h.set(m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10])}return function(l,m){const P=this.geometry.getAttribute("position");t.set(0,0,0),t.applyMatrix4(m),this.updateNodeCenter(l,t);for(let g=0;g<this.localHeadGeometry.length;g++)u[g].copy(this.localHeadGeometry[g]);for(let g=0;g<this.localHeadGeometry.length;g++)u[g].applyMatrix4(m);if(this.lastNodeCenter&&this.orientToMovement&&(f(e,m),a.set(0,0,-1),a.applyMatrix3(e),s.copy(this.currentNodeCenter),s.sub(this.lastNodeCenter),s.normalize(),s.lengthSq()<=1e-4&&this.lastOrientationDir&&s.copy(this.lastOrientationDir),s.lengthSq()>1e-4)){this.lastOrientationDir||(this.lastOrientationDir=new p),i.setFromUnitVectors(a,s),r.copy(this.currentNodeCenter);for(let g=0;g<this.localHeadGeometry.length;g++){const C=u[g];C.sub(r),C.applyQuaternion(i),C.add(r)}}for(let g=0;g<this.localHeadGeometry.length;g++){const C=(this.VerticesPerNode*l+g)*c.PositionComponentCount,S=u[g];P.array[C]=S.x,P.array[C+1]=S.y,P.array[C+2]=S.z}P.needsUpdate=!0,P.updateRange.offset=l*this.VerticesPerNode*c.PositionComponentCount,P.updateRange.count=this.VerticesPerNode*c.PositionComponentCount}}());x(this,"connectNodes",function(){const e={attribute:null,offset:0,count:-1};return function(t,r){const a=this.geometry.getIndex();for(let s=0;s<this.localHeadGeometry.length-1;s++){const u=this.VerticesPerNode*t+s,f=this.VerticesPerNode*r+s,h=(t*this.FacesPerNode+s*c.FacesPerQuad)*c.IndicesPerFace;a.array[h]=u,a.array[h+1]=f,a.array[h+2]=u+1,a.array[h+3]=f,a.array[h+4]=f+1,a.array[h+5]=u+1}return a.needsUpdate=!0,a.updateRange.count=-1,e.attribute=a,e.offset=t*this.FacesPerNode*c.IndicesPerFace,e.count=this.FacesPerNode*c.IndicesPerFace,e}}());x(this,"disconnectNodes",function(){const e={attribute:null,offset:0,count:-1};return function(t){const r=this.geometry.getIndex();for(let a=0;a<this.localHeadGeometry.length-1;a++){const s=(t*this.FacesPerNode+a*c.FacesPerQuad)*c.IndicesPerFace;r.array[s]=0,r.array[s+1]=0,r.array[s+2]=0,r.array[s+3]=0,r.array[s+4]=0,r.array[s+5]=0}return r.needsUpdate=!0,r.updateRange.count=-1,e.attribute=r,e.offset=t*this.FacesPerNode*c.IndicesPerFace,e.count=this.FacesPerNode*c.IndicesPerFace,e}}());this.active=!1,this.orientToMovement=!1,i&&(this.orientToMovement=!0),this.scene=e,this.geometry=null,this.mesh=null,this.nodeCenters=null,this.lastNodeCenter=null,this.currentNodeCenter=null,this.lastOrientationDir=null,this.nodeIDs=null,this.currentLength=0,this.currentEnd=0,this.currentNodeID=0,this.advanceFrequency=60,this.advancePeriod=1/this.advanceFrequency,this.lastAdvanceTime=0,this.paused=!1,this.pauseAdvanceUpdateTimeDiff=0}setAdvanceFrequency(e){this.advanceFrequency=e,this.advancePeriod=1/this.advanceFrequency}initialize(e,i,t,r,a,s){this.deactivate(),this.destroyMesh(),this.length=i>0?i+1:0,this.dragTexture=t?1:0,this.targetObject=s,this.initializeLocalHeadGeometry(r,a),this.nodeIDs=[],this.nodeCenters=[];for(let u=0;u<this.length;u++)this.nodeIDs[u]=-1,this.nodeCenters[u]=new p;this.material=e,this.initializeGeometry(),this.initializeMesh(),this.material.uniforms.trailLength.value=0,this.material.uniforms.minID.value=0,this.material.uniforms.maxID.value=0,this.material.uniforms.dragTexture.value=this.dragTexture,this.material.uniforms.maxTrailLength.value=this.length,this.material.uniforms.verticesPerNode.value=this.VerticesPerNode,this.material.uniforms.textureTileFactor.value=new q(1,1),this.reset()}initializeLocalHeadGeometry(e,i){if(this.localHeadGeometry=[],!i)halfWidth=e||1,halfWidth=halfWidth/2,this.localHeadGeometry.push(new p(-halfWidth,0,0)),this.localHeadGeometry.push(new p(halfWidth,0,0)),this.VerticesPerNode=2;else{this.VerticesPerNode=0;for(let t=0;t<i.length&&t<c.MaxHeadVertices;t++){const r=i[t];if(r&&r instanceof p){const a=new p;a.copy(r),this.localHeadGeometry.push(a),this.VerticesPerNode++}}}this.FacesPerNode=(this.VerticesPerNode-1)*2,this.FaceIndicesPerNode=this.FacesPerNode*3}initializeGeometry(){this.vertexCount=this.length*this.VerticesPerNode,this.faceCount=this.length*this.FacesPerNode;const e=new $,i=new Float32Array(this.vertexCount),t=new Float32Array(this.vertexCount*this.VerticesPerNode),r=new Float32Array(this.vertexCount*c.PositionComponentCount),a=new Float32Array(this.vertexCount*c.PositionComponentCount),s=new Float32Array(this.vertexCount*c.UVComponentCount),u=new Uint32Array(this.faceCount*c.IndicesPerFace),f=new b(i,1);f.dynamic=!0,e.setAttribute("nodeID",f);const h=new b(t,1);h.dynamic=!0,e.setAttribute("nodeVertexID",h);const l=new b(a,c.PositionComponentCount);l.dynamic=!0,e.setAttribute("nodeCenter",l);const m=new b(r,c.PositionComponentCount);m.dynamic=!0,e.setAttribute("position",m);const P=new b(s,c.UVComponentCount);P.dynamic=!0,e.setAttribute("uv",P);const g=new b(u,1);g.dynamic=!0,e.setIndex(g),this.geometry=e}zeroVertices(){const e=this.geometry.getAttribute("position");for(let i=0;i<this.vertexCount;i++){const t=i*3;e.array[t]=0,e.array[t+1]=0,e.array[t+2]=0}e.needsUpdate=!0,e.updateRange.count=-1}zeroIndices(){const e=this.geometry.getIndex();for(let i=0;i<this.faceCount;i++){const t=i*3;e.array[t]=0,e.array[t+1]=0,e.array[t+2]=0}e.needsUpdate=!0,e.updateRange.count=-1}formInitialFaces(){this.zeroIndices();const e=this.geometry.getIndex();for(let i=0;i<this.length-1;i++)this.connectNodes(i,i+1);e.needsUpdate=!0,e.updateRange.count=-1}initializeMesh(){this.mesh=new H(this.geometry,this.material),this.mesh.dynamic=!0,this.mesh.matrixAutoUpdate=!1}destroyMesh(){this.mesh&&(this.scene.remove(this.mesh),this.mesh=null)}reset(){this.currentLength=0,this.currentEnd=-1,this.lastNodeCenter=null,this.currentNodeCenter=null,this.lastOrientationDir=null,this.currentNodeID=0,this.formInitialFaces(),this.zeroVertices(),this.geometry.setDrawRange(0,0)}updateUniforms(){this.currentLength<this.length?this.material.uniforms.minID.value=0:this.material.uniforms.minID.value=this.currentNodeID-this.length,this.material.uniforms.maxID.value=this.currentNodeID,this.material.uniforms.trailLength.value=this.currentLength,this.material.uniforms.maxTrailLength.value=this.length,this.material.uniforms.verticesPerNode.value=this.VerticesPerNode}advanceWithPositionAndOrientation(e,i){this.advanceGeometry({position:e,tangent:i},null)}advanceWithTransform(e){this.advanceGeometry(null,e)}currentTime(){return performance.now()/1e3}pause(){this.paused||(this.paused=!0,this.pauseAdvanceUpdateTimeDiff=this.currentTime()-this.lastAdvanceTime)}resume(){this.paused&&(this.paused=!1,this.lastAdvanceTime=this.currentTime()-this.pauseAdvanceUpdateTimeDiff)}update(){if(!this.paused){const e=this.currentTime();this.lastAdvanceTime||(this.lastAdvanceTime=e),e-this.lastAdvanceTime>this.advancePeriod?(this.advance(),this.lastAdvanceTime=e):this.updateHead()}}updateNodeID(e,i){this.nodeIDs[e]=i;const t=this.geometry.getAttribute("nodeID"),r=this.geometry.getAttribute("nodeVertexID");for(let a=0;a<this.VerticesPerNode;a++){const s=e*this.VerticesPerNode+a;t.array[s]=i,r.array[s]=a}t.needsUpdate=!0,r.needsUpdate=!0,t.updateRange.offset=e*this.VerticesPerNode,t.updateRange.count=this.VerticesPerNode,r.updateRange.offset=e*this.VerticesPerNode,r.updateRange.count=this.VerticesPerNode}updateNodeCenter(e,i){this.lastNodeCenter=this.currentNodeCenter,this.currentNodeCenter=this.nodeCenters[e],this.currentNodeCenter.copy(i);const t=this.geometry.getAttribute("nodeCenter");for(let r=0;r<this.VerticesPerNode;r++){const a=(e*this.VerticesPerNode+r)*3;t.array[a]=i.x,t.array[a+1]=i.y,t.array[a+2]=i.z}t.needsUpdate=!0,t.updateRange.offset=e*this.VerticesPerNode*c.PositionComponentCount,t.updateRange.count=this.VerticesPerNode*c.PositionComponentCount}deactivate(){this.isActive&&(this.scene.remove(this.mesh),this.isActive=!1)}activate(){this.isActive||(this.scene.add(this.mesh),this.isActive=!0)}static createMaterial(e,i,t){return t=t||{},t.trailLength={type:"f",value:null},t.verticesPerNode={type:"f",value:null},t.minID={type:"f",value:null},t.maxID={type:"f",value:null},t.dragTexture={type:"f",value:null},t.maxTrailLength={type:"f",value:null},t.textureTileFactor={type:"v2",value:null},t.headColor={type:"v4",value:new j},t.tailColor={type:"v4",value:new j},e=e||c.Shader.BaseVertexShader,i=i||c.Shader.BaseFragmentShader,new ee({uniforms:t,vertexShader:e,fragmentShader:i,transparent:!0,alphaTest:.5,blending:te,blendSrc:ne,blendDst:ie,blendEquation:re,depthTest:!0,depthWrite:!1,side:ae})}static createBaseMaterial(e){return c.createMaterial(c.Shader.BaseVertexShader,c.Shader.BaseFragmentShader,e)}static createTexturedMaterial(e){return e={},e.trailTexture={type:"t",value:null},c.createMaterial(c.Shader.TexturedVertexShader,c.Shader.TexturedFragmentShader,e)}static get MaxHeadVertices(){return 128}static get LocalOrientationTangent(){return _LocalOrientationTangent}static get LocalHeadOrigin(){return _LocalHeadOrigin}static get PositionComponentCount(){return 3}static get UVComponentCount(){return 2}static get IndicesPerFace(){return 3}static get FacesPerQuad(){return 2}};x(c,"_LocalOrientationTangent",new p(1,0,0)),x(c,"_LocalHeadOrigin",new p(0,0,0)),x(c,"Shader",{get BaseVertexVars(){return["attribute float nodeID;","attribute float nodeVertexID;","attribute vec3 nodeCenter;","uniform float minID;","uniform float maxID;","uniform float trailLength;","uniform float maxTrailLength;","uniform float verticesPerNode;","uniform vec2 textureTileFactor;","uniform vec4 headColor;","uniform vec4 tailColor;","varying vec4 vColor;"].join(`
`)},get TexturedVertexVars(){return[this.BaseVertexVars,"varying vec2 vUV;","uniform float dragTexture;"].join(`
`)},BaseFragmentVars:["varying vec4 vColor;","uniform sampler2D trailTexture;"].join(`
`),get TexturedFragmentVars(){return[this.BaseFragmentVars,"varying vec2 vUV;"].join(`
`)},get VertexShaderCore(){return["float fraction = (maxID - nodeID) / (maxID - minID);","vColor = (1.0 - fraction) * headColor + fraction * tailColor;","vec4 realPosition = vec4((1.0 - fraction) * position.xyz + fraction * nodeCenter.xyz, 1.0); "].join(`
`)},get BaseVertexShader(){return[this.BaseVertexVars,"void main() { ",this.VertexShaderCore,"gl_Position = projectionMatrix * viewMatrix * realPosition;","}"].join(`
`)},get BaseFragmentShader(){return[this.BaseFragmentVars,"void main() { ","gl_FragColor = vColor;","}"].join(`
`)},get TexturedVertexShader(){return[this.TexturedVertexVars,"void main() { ",this.VertexShaderCore,"float s = 0.0;","float t = 0.0;","if (dragTexture == 1.0) { ","   s = fraction *  textureTileFactor.s; ","     t = (nodeVertexID / verticesPerNode) * textureTileFactor.t;","} else { ","    s = nodeID / maxTrailLength * textureTileFactor.s;","     t = (nodeVertexID / verticesPerNode) * textureTileFactor.t;","}","vUV = vec2(s, t); ","gl_Position = projectionMatrix * viewMatrix * realPosition;","}"].join(`
`)},get TexturedFragmentShader(){return[this.TexturedFragmentVars,"void main() { ","vec4 textureColor = texture2D(trailTexture, vUV);","gl_FragColor = vColor * textureColor;","}"].join(`
`)}});let L=c,O=[];const Ce=document.querySelector("#app"),V=new se({antialias:!0});V.setPixelRatio(window.devicePixelRatio);V.setSize(window.innerWidth,window.innerHeight);Ce.appendChild(V.domElement);document.body.appendChild(V.domElement);const D=new oe;D.background=new ce("#5BB2F0");const N=new de(35,window.innerWidth/window.innerHeight,1,1e3);N.position.set(20,50,200);const Ne=new he("white",.2),Ve=new le("#ffffff","#ff00ff",.8),Fe=new ue("white",.8);Fe.position.set(-1,1,1);D.add(Ne,Ve);const y=new me(N,V.domElement);y.enableDamping=!0;y.dampingFactor=.05;y.screenSpacePanning=!1;y.enableRotate=!0;y.rotateSpeed=.5;y.enableZoom=!0;y.zoomSpeed=.5;y.minDistance=100;y.maxDistance=800;y.target=new p(0,0,0);const k=new ye(O,N,V.domElement);k.addEventListener("dragstart",function(){y.enabled=!1});k.addEventListener("dragend",function(){y.enabled=!0});const De=()=>{N.aspect=window.innerWidth/window.innerHeight,N.updateProjectionMatrix(),V.setSize(window.innerWidth,window.innerHeight)};window.addEventListener("resize",De);const z=new q,T=new p,B=new p,W=new pe,R=new fe;let M=[];window.addEventListener("keydown",function(n){z.x=n.clientX/window.innerWidth*2-1,z.y=-(n.clientY/window.innerHeight)*2+1,B.copy(N.position).normalize(),W.setFromNormalAndCoplanarPoint(B,D.position),R.setFromCamera(z,N),R.ray.intersectPlane(W,T);const o=new H(new U(2,30,30),new ge({color:16103345,metalness:0,roughness:0}));O.push(o),D.add(o);let e=new Q(T.x,T.y,T.z,100);M.push(e),o.position.copy(T)});const be=new ve({color:"#1da2d8"}),Ie=new U(.5,64,64);let A=[],d=[],w=[];const X=[];for(let n=0;n<200;n++)d[n]=new Q(Math.random()*1e3,Math.random()*1e3,Math.random()*1e3,Math.random()*5),A[n]=new H(Ie,be),A[n].position.set(d[n].pos.x,d[n].pos.y,d[n].pos.z),D.add(A[n]),X.push(new p(-1,0,0),new p(1,0,0),new p(1,0,0)),F(n);function F(n){w[n]=new L(D,!1),w[n].setAdvanceFrequency(50);const o=L.createBaseMaterial();w[n].initialize(o,50,!1,2,X,A[n]),o.uniforms.headColor.value.set(.1,.4,.9,1),o.uniforms.tailColor.value.set(.2,.2,.9,.5),w[n].activate()}let Te=xe(),I=1e3,v=2;const Y=()=>{requestAnimationFrame(Y);for(let n=0;n<d.length;n++){if(M.length>0)for(let o=0;o<M.length;o++)M[o].attract(d[n]),M[o].pos=O[o].position;d[n].follow(Te),d[n].pos.x>I&&(d[n].pos.x=0,w[n].deactivate(),F(n)),d[n].pos.y>I&&(d[n].pos.y=0,w[n].deactivate(),F(n)),d[n].pos.z>I&&(d[n].pos.z=0,w[n].deactivate(),F(n)),d[n].pos.x<0&&(d[n].pos.x=I,w[n].deactivate(),F(n)),d[n].pos.y<0&&(d[n].pos.y=I,w[n].deactivate(),F(n)),d[n].pos.z<0&&(d[n].pos.z=I,w[n].deactivate(),F(n)),d[n].vel.x>v&&(d[n].vel.x=v),d[n].vel.y>v&&(d[n].vel.y=v),d[n].vel.z>v&&(d[n].vel.z=v),d[n].vel.x<-v&&(d[n].vel.x=-v),d[n].vel.y<-v&&(d[n].vel.y=-v),d[n].vel.z<-v&&(d[n].vel.z=-v),A[n].position.set(d[n].pos.x/10,d[n].pos.y/10,d[n].pos.z/10),w[n].update()}V.render(D,N)};Y();
